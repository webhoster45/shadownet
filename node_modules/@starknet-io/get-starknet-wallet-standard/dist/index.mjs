import { StandardConnect, StandardDisconnect, StandardEvents } from '@wallet-standard/features';
import { WELL_KNOWN_STARKNET_CHAINS, formatStarknetChainId, isStarknetChain } from './chains.mjs';
import { StarknetWalletApi } from './features.mjs';
import 'ox';

var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var __privateMethod = (obj, member, method) => {
  __accessCheck(obj, member, "access private method");
  return method;
};
var _listeners, _account, _connect, _disconnect, _on, _emit, emit_fn, _off, off_fn, _disconnected, disconnected_fn, _onAccountsChanged, onAccountsChanged_fn, _onNetworkChanged, onNetworkChanged_fn, _updateAccount, updateAccount_fn, _request, request_fn, _getStarknetChain, getStarknetChain_fn;
class StarknetInjectedWallet {
  constructor(injected) {
    this.injected = injected;
    __privateAdd(this, _emit);
    __privateAdd(this, _off);
    __privateAdd(this, _disconnected);
    __privateAdd(this, _onAccountsChanged);
    __privateAdd(this, _onNetworkChanged);
    __privateAdd(this, _updateAccount);
    __privateAdd(this, _request);
    __privateAdd(this, _getStarknetChain);
    __privateAdd(this, _listeners, {});
    __privateAdd(this, _account, null);
    __privateAdd(this, _connect, async ({ silent }) => {
      if (!__privateGet(this, _account)) {
        const accounts = await this.injected.request({
          type: "wallet_requestAccounts",
          params: {
            silent_mode: silent
          }
        });
        if (accounts.length === 0) {
          return { accounts: [] };
        }
        await __privateMethod(this, _updateAccount, updateAccount_fn).call(this, accounts);
      }
      return { accounts: this.accounts };
    });
    __privateAdd(this, _disconnect, async () => {
      __privateMethod(this, _disconnected, disconnected_fn).call(this);
    });
    __privateAdd(this, _on, (event, listener) => {
      if (!__privateGet(this, _listeners)[event]) {
        __privateGet(this, _listeners)[event] = [];
      }
      __privateGet(this, _listeners)[event].push(listener);
      return () => __privateMethod(this, _off, off_fn).call(this, event, listener);
    });
    this.injected.on("accountsChanged", __privateMethod(this, _onAccountsChanged, onAccountsChanged_fn).bind(this));
    this.injected.on("networkChanged", __privateMethod(this, _onNetworkChanged, onNetworkChanged_fn).bind(this));
  }
  get version() {
    return "1.0.0";
  }
  get name() {
    return this.injected.name;
  }
  get icon() {
    if (typeof this.injected.icon === "string") {
      return this.injected.icon;
    }
    return this.injected.icon.light;
  }
  get features() {
    return {
      [StandardConnect]: {
        version: "1.0.0",
        connect: __privateGet(this, _connect).bind(this)
      },
      [StandardDisconnect]: {
        version: "1.0.0",
        disconnect: __privateGet(this, _disconnect).bind(this)
      },
      [StandardEvents]: {
        version: "1.0.0",
        on: __privateGet(this, _on).bind(this)
      },
      [StarknetWalletApi]: {
        id: this.injected.id,
        version: "1.0.0",
        request: __privateMethod(this, _request, request_fn).bind(this),
        walletVersion: this.injected.version
      }
    };
  }
  get chains() {
    return WELL_KNOWN_STARKNET_CHAINS.slice();
  }
  get accounts() {
    if (__privateGet(this, _account)) {
      return [
        {
          address: __privateGet(this, _account).address,
          publicKey: new Uint8Array(),
          chains: [__privateGet(this, _account).chain],
          features: []
        }
      ];
    }
    return [];
  }
}
_listeners = new WeakMap();
_account = new WeakMap();
_connect = new WeakMap();
_disconnect = new WeakMap();
_on = new WeakMap();
_emit = new WeakSet();
emit_fn = function(event, ...args) {
  if (!__privateGet(this, _listeners)[event])
    return;
  for (const listener of __privateGet(this, _listeners)[event]) {
    listener.apply(null, args);
  }
};
_off = new WeakSet();
off_fn = function(event, listener) {
  __privateGet(this, _listeners)[event] = __privateGet(this, _listeners)[event]?.filter(
    (existingListener) => listener !== existingListener
  );
};
_disconnected = new WeakSet();
disconnected_fn = function() {
  if (__privateGet(this, _account)) {
    __privateSet(this, _account, null);
    __privateMethod(this, _emit, emit_fn).call(this, "change", { accounts: this.accounts });
  }
};
_onAccountsChanged = new WeakSet();
onAccountsChanged_fn = async function(accounts) {
  if (!accounts || accounts.length === 0) {
    __privateMethod(this, _disconnected, disconnected_fn).call(this);
    return;
  }
  if (!__privateGet(this, _account)) {
    return;
  }
  await __privateMethod(this, _updateAccount, updateAccount_fn).call(this, accounts);
};
_onNetworkChanged = new WeakSet();
onNetworkChanged_fn = function(chainId, accounts) {
  if (!chainId) {
    __privateMethod(this, _disconnected, disconnected_fn).call(this);
    return;
  }
  if (!__privateGet(this, _account)) {
    return;
  }
  const chain = formatStarknetChainId(chainId);
  if (!isStarknetChain(chain)) {
    throw new Error(`Invalid Starknet chain: ${chain}`);
  }
  if (accounts?.length > 0) {
    const [account] = accounts;
    __privateSet(this, _account, { address: account, chain });
    __privateMethod(this, _emit, emit_fn).call(this, "change", { accounts: this.accounts });
  } else {
    __privateSet(this, _account, { address: __privateGet(this, _account)?.address, chain });
    __privateMethod(this, _emit, emit_fn).call(this, "change", { accounts: this.accounts });
  }
};
_updateAccount = new WeakSet();
updateAccount_fn = async function(accounts) {
  if (accounts.length === 0) {
    return;
  }
  const [account] = accounts;
  if (__privateGet(this, _account)?.chain) {
    __privateGet(this, _account).address = account;
    __privateMethod(this, _emit, emit_fn).call(this, "change", { accounts: this.accounts });
  } else {
    const chain = await __privateMethod(this, _getStarknetChain, getStarknetChain_fn).call(this);
    __privateSet(this, _account, { address: account, chain });
    __privateMethod(this, _emit, emit_fn).call(this, "change", { accounts: this.accounts });
  }
};
_request = new WeakSet();
request_fn = function(...args) {
  return this.injected.request(...args);
};
_getStarknetChain = new WeakSet();
getStarknetChain_fn = async function() {
  const chainId = await this.injected.request({
    type: "wallet_requestChainId"
  });
  const chain = formatStarknetChainId(chainId);
  if (!isStarknetChain(chain)) {
    throw new Error(`Invalid Starknet chain: ${chain}`);
  }
  return chain;
};

export { StarknetInjectedWallet };
//# sourceMappingURL=index.mjs.map
